# Static analyzer annotations for GC correctness in C code

## General Overview

Since Julia's GC is precise, it needs to maintain correct rooting information for any value that may be referenced at any time GC may occur.
> JuliaのGCは正確であるため、GCが発生する可能性があるときにいつでも参照できる任意の値に対して正しい根拠情報を維持する必要があります。
These places are known as `safepoints` and in the function local context, we extend this designation to any function call that may recursively end up at a safepoint.
> これらの場所は `safepoints`と呼ばれ、関数のローカルコンテキストでは、再帰的にsafepointに終わるかもしれない関数呼び出しにこの指定を拡張します。

In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC rooting in the LLVM codegen devdocs).
> 生成されたコードでは、これはGCルート配置パスによって自動的に処理されます（LLVM codegen devdocsのGCルート設定の章を参照）。
However, in C code, we need to inform the runtime of any GC roots manually.
> しかし、Cコードでは、実行時にGCルートを手動で通知する必要があります。
This is done using the following macros:
> これは、次のマクロを使用して行われます。

```
// The value assigned to any slot passed as an argument to these
// is rooted for the duration of this GC frame.
JL_GC_PUSH{1,...,6}(args...)
// The values assigned into the size `n` array `rts` are rooted
// for the duration of this GC frame.
JL_GC_PUSHARGS(rts, n)
// Pop a GC frame
JL_GC_POP
```

If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory corruption.
> これらのマクロが必要な場所で使用されていない場合や、誤って使用された場合は、メモリが破壊されます。
As such it is very important that they are placed correctly in all applicable code.
> したがって、すべての適用可能なコードに正しく配置されていることが非常に重要です。

As such, we employ static analysis (and in particular the clang static analyzer) to help ensure that these macros are used correctly.
> したがって、これらのマクロが正しく使用されるようにするために、静的分析（特にclangスタティックアナライザー）を採用しています。
The remainder of this document gives an overview of this static analysis and describes the support needed in the julia code base to make things work.
> この文書の残りの部分では、この静的分析の概要を説明し、Juliaコードベースで必要なサポートを行い、機能させるようにしています。

## GC Invariants

There is two simple invariants correctness:
> 2つの単純な不変量の正しさがあります。
- All GC_PUSH calls need to be followed by an appropriate GC_POP (in practice we enforce this at the function level)
> - すべてのGC_PUSH呼び出しの後に適切なGC_POPを付ける必要があります（実際には、これを関数レベルで実行します）
- If a value was previously not rooted at any safepoint, it may no longer be referenced afterwards
> - あるセーフポイントで以前に値が設定されていなかった場合は、後でその値を参照することはできません

Of course the devil is in the details here.
> もちろん悪魔はここに詳しく書いてあります。
In particular to satisfy the second of the above conditions, we need to know:
> 特に、上記の条件の2番目を満たすために、我々は知る必要があります：
- Which calls are safepoints and which are not
> - どの呼がセーフポイントであり、どの呼がそうでないか
- Which values are rooted at any given safepoint and which are not
> - 与えられたセーフポイントに根ざしている値とそうでないもの
- When is a value referenced
> - 値が参照されるのはいつですか

For the second point in particular, we need to know which memory locations will be considered rooting at runtime (i.e. values assigned to such locations are rooted).
> 特に、第2の点については、実行時にどのメモリ位置がルーピングとみなされるか（つまり、そのような位置に割り当てられた値が根付いているかどうか）を知る必要があります。
This includes locations explicitly designated as such by passing them to one of the `GC_PUSH` macros, globally rooted locations and values, as well as any location recursively reachable from one of those locations.
> これには、 `GC_PUSH` マクロ、グローバルにルートされた場所と値、そしてそれらの場所の1つから再帰的に到達可能な場所の1つに渡すことで明示的に指定された場所が含まれます。

## Static Analysis Algorithm

The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a large number of special cases and intricacies of C and C++).
> アイデア自体は非常にシンプルですが、実装はかなり複雑です（主にCおよびC ++の特殊なケースや複雑さのために）。
In essence, we keep track of all locations that are rooting, all values that are rootable and any expression (assignments, allocations, etc) affect the rootedness of any rootable values.
> 本質的に、我々は根づいているすべての場所、根っからのすべての値、あらゆる式（割り当て、割り当てなど）がルート可能な値の根強さに影響を与えます。
Then, at any safepoint, we perform a "symbolic GC" and poison any values that are not rooted at said location.
> 次に、いずれかのセーフポイントで、「シンボリックGC」を実行し、前記場所に根ざしていない値を害します。
If these values are later referenced, we emit an error.
> これらの値が後で参照されると、エラーが発生します。

The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors.
> clangスタティック・アナライザは、状態のグラフを作成し、このグラフをエラーの原因について調べることによって動作します。
Several nodes in this graph are generated by the analyzer itself (e.g. for control flow), but the definitions above augment this graph with our own state.
> このグラフのいくつかのノードは、アナライザ自体（例えば制御フロー用）によって生成されますが、上記定義はこのグラフを独自の状態で補強します。

The static analyzer is interprocedural and can analyze control flow across function boundaries.
> スタティック・アナライザはプロシージャ間であり、関数境界をまたいだ制御フローを解析できます。
However, the static analyzer is not fully recursive and makes heuristic decisions about which calls to explore (additionally some calls are cross-translation unit and invisible to the analyzer).
> しかし、スタティック・アナライザは完全に再帰的ではなく、探索するコールについてヒューリスティックな決定を行います（さらに、一部のコールは、クロス・トランスレーション・ユニットであり、アナライザには見えません）。
In our case, our definition of correctness requires total information.
> 私たちの場合、正しさの定義には完全な情報が必要です。
As such, we need to annotate the prototypes of all function calls with whatever information the analysis required, even if that information would otherwise be available by interprocedural static analysis.
> したがって、たとえそうでなければプロシージャ間の静的分析によって情報が利用可能であっても、分析が必要とする情報をすべての関数呼び出しのプロトタイプに注釈を付ける必要があります。

Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a given function are indeed correct given the implementation of said function.
> しかし幸運にも、このプロシージャ内の分析を使用して、与えられた関数に実装された注釈が実際には正しいことを確実にすることができます。

## The analyzer annotations

These annotations are found in src/support/analyzer_annotations.h.
> これらの注釈は src/support/analyzer_annotations.h にあります。
The are only active when the analyzer is being used and expand either to nothing (for prototype annotations) or to no-ops (for function like annotations).
> アナライザーが使用されていて、プロトタイプアノテーションの場合は何も表示しないか、注釈のような機能の場合はノーオプスに展開する場合にのみ有効です。

### JL_NOTSAFEPOINT

This is perhaps the most common annotation, and should be placed on any function that is known not to possibly lead to reaching a GC safepoint.
> これはおそらく最も一般的な注釈であり、GCセーフポイントに到達しない可能性があることがわかっている機能に配置する必要があります。
In general, it is only safe for such a function to perform arithmetic, memory accesses and calls to functions either annotated JL_NOTSAFEPOINT or otherwise known not to be safepoints (e.g. function in the C standard library, which are hardcoded as such in the analyzer)
> 一般に、このような関数は、注釈付きJL_NOTSAFEPOINTまたはセーフポイントではないことが知られている関数への算術、メモリアクセスおよび呼び出しを行うだけで安全である（例えば、アナライザ内でハードコーディングされたC標準ライブラリ内で機能する）

It is valid to keep values unrooted across calls to any function annotated with this attribute:
> このアトリビュートで注釈を付けられた関数への呼び出しの間に値をルーティングしないことは有効です：

Usage Example:
> 使用例：

```c
void jl_get_one() JL_NOTSAFEPOINT {
  return 1;
}

jl_value_t *example() {
  jl_value_t *val = jl_alloc_whatever();
  // This is valid, even though `val` is unrooted, because
  // jl_get_one is not a safepoint
  jl_get_one();
  return val;
}
```

### JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY

When `JL_MAYBE_UNROOTED` is annotated as an argument on a function, indicates that said argument may be passed, even if it is not rooted.
> `JL_MAYBE_UNROOTED`が関数の引数として注釈されている場合、それが根づけられていなくても、引数が渡されることを示します。
In the ordinary course of events, the julia ABI guarantees that callers root values before passing them to callees.
> 通常のイベントでは、julia ABIは、発信者が通話先に値を渡す前にそれを保証します。
However, some functions do not follow this ABI and allow values to be passed to them even though they are not rooted.
> しかし、一部の関数はこのABIに従わず、値がルートされていなくてもその値を渡すことができます。
Note however, that this does not automatically imply that said argument will be preserved.
> ただし、これは自動的に前記引数が保持されることを意味しないことに注意してください。
The `ROOTS_TEMPORARILY` annotation provides the stronger guarantee that, not only may the value be unrooted when passed, it will also be preserved across any internal safepoints by the callee.
> `ROOTS_TEMPORARILY` アノテーションは、値が渡されたときにルーティングされないだけでなく、呼び出される側の内部セーフポイントにも保持されるという強い保証を提供します。

Note that JL_NOTSAFEPOINT essentially implies JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY, because the rootedness of an argument is irrelevant if the function contains no safepoints.
> JL_NOTSAFEPOINTは、本質的にJL_MAYBE_UNROOTED / JL_ROOTS_TEMPORARILYを意味することに注意してください。なぜなら、関数にセーフポイントが含まれていない場合、引数の根強さは無関係であるからです。

One additional point to note is that these annotations apply on both the caller and the callee side.
> 注目すべき点の1つは、これらの注釈が呼び出し元と呼び出し先の両方に適用されることです。
On the caller side, they lift rootedness restrictions that are normally required for julia ABI functions.
> 呼び出し元側では、通常、julia ABI関数に必要な根本的な制限が解除されます。
On the callee side, they have the reverse effect of preventing these arguments from being considered implicitly rooted.
> 被呼び出し側では、これらの引数が暗黙的に根づいているとみなされるのを防ぐという逆の効果があります。

If either of these annotations is applied to the function as a whole, it applies to all arguments of the function.
> これらの注釈のいずれかが関数全体に適用された場合、関数のすべての引数に適用されます。
This should generally only be necessary for varargs functions.
> これは一般にvarargs関数にのみ必要です。

Usage example:
> 使用例：
```c
JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);
jl_value_t *jl_alloc_error();

void example() {
  // The return value of the allocation is unrooted. This would normally
  // be an error, but is allowed because of the above annotation.
  jl_throw(jl_alloc_error());
}
```

### JL_PROPAGATES_ROOT

This annotation is commonly found on accessor functions that return one rootable object stored within another.
> この注釈は一般に、別のオブジェクトに格納されているルート可能オブジェクトを返すアクセサ関数で検出されます。
When annotated on a function argument, it tells the analyzer that the root for that argument also applies to the value returned by the function.
> 関数の引数に注釈を付けると、その引数のルートが関数によって返された値にも適用されることがアナライザに伝えられます。

Usage Example:
> 使用例：
```c
jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;

size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_svecref(svec, 1)
  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,
  // jl_svecref propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}
```

### JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT

This is essentially the assignment counterpart to `JL_PROPAGATES_ROOT`.
> これは本質的に `JL_PROPAGATES_ROOT`の代入に相当します。
When assigning a value to a field of another value that is already rooted, the assigned value will inherit the root of the value it is assigned into.
> すでにルートされている別の値のフィールドに値を割り当てると、割り当てられた値は割り当てられている値のルートを継承します。

Usage Example:
> 使用例：
```c
void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT


size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_box_long(10000);
  jl_svecset(svec, val);
  // This is valid, because the annotations imply that the
  // jl_svecset propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}
```

### JL_GC_DISABLED

This annotation implies that this function is only called with the GC runtime-disabled.
> この注釈は、この関数がGCランタイムでのみ呼び出されることを意味します。
Functions of this kind are most often encountered during startup and in the GC code itself.
> この種類の関数は、起動時およびGCコード自体で最も頻繁に遭遇します。
Note that this annotation is checked against the runtime enable/disable calls, so clang will know if you lie.
> このアノテーションはランタイムの有効/無効の呼び出しと照合されるので、あなたが存在するかどうかを知ることができます。
This is not a good way to disable processing of a given function if the GC is not actually disabled (use ifdef __clang_analyzer__ for that if you must).
> これは、GCが実際に無効化されていない場合（もし必要ならばifdef __clang_analyzer__を使用する）、指定された関数の処理を無効にする良い方法ではありません。

Usage example:
> 使用例
```c
void jl_do_magic() JL_GC_DISABLED {
  // Wildly allocate here with no regard for roots
}

void example() {
  int en = jl_gc_enable(0);
  jl_do_magic();
  jl_gc_enable(en);
}
```

### JL_REQUIRE_ROOTED_SLOT

This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned to this slot will be rooted).
> このアノテーションでは、発信者がルートになっているスロットを通過する必要があります（つまり、このスロットに割り当てられた値はルートになります）。

Usage example:
> 使用例
```c
void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {
  *slot = jl_box_long(1);
  // Ok, only, because the slot was annotated as rooting
  jl_gc_safepoint();
}

void example() {
  jl_value_t *slot = NULL;
  JL_GC_PUSH1(&slot);
  jl_do_processing(&slot);
  JL_GC_POP();
}
```

### JL_GLOBALLY_ROOTED

This annotation implies that a given value is always globally rooted.
> このアノテーションは、与えられた値が常にグローバルに根付いていることを意味します。
It can be applied to global variable declarations, in which case it will apply to the value of those variables (or values if the declaration if for an array), or to functions, in which case it will apply to the return value of such functions (e.g. for functions that always return some private, globally rooted value).
> グローバル変数宣言に適用することができます。その場合、それらの変数の値（または配列の場合は宣言の場合は値）に適用されます。関数の場合は、そのような関数の戻り値に適用されます （例えば、常にプライベートでグローバルに根付いた値を返す関数の場合）。

Usage example:
> 使用例
```
extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;
jl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;
```

### JL_ALWAYS_LEAFTYPE
This annotations is essentially equivalent to JL_GLOBALLY_ROOTED, except that is should only be used if those values are globally rooted by virtue of being a leaftype.
> このアノテーションはJL_GLOBALLY_ROOTEDと本質的に同じですが、これらの値がレガシティブであることによってグローバルに根付いている場合にのみ使用してください。
The rooting of leaftypes is a bit complicated, and we can generally assume that leaftypes are rooted where they are used, but we may refine this property in the future, so the separate annotation helps split out the reason for being globally rooted.
> しかし、私たちは、将来、このプロパティを改良するかもしれないので、別々のアノテーションは、グローバルに根付いた理由を分けるのに役立ちます。

The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots on these paths.
> このアナライザは、自動的にライフタイプのチェックも検出し、これらのパス上のGCルートの欠落については不平を言いません。

```
JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;
```

### JL_GC_PROMISE_ROOTED

This is a function-like annotation.
> これは、関数のような注釈です。
Any value passed to this annotation will be considered rooted for the scope of the current function.
> このアノテーションに渡された値は、現在の関数のスコープの根源とみなされます。
It is designed as an escape hatch for analyzer inadequacy or complicated situations.
> これは、アナライザの不備や複雑な状況のためのエスケープハッチとして設計されています。
However, it should be used sparingly, in favor of improving the analyzer itself.
> ただし、アナライザ自体を改善することを念頭に置き、控えめに使用する必要があります。

```
void example() {
  jl_value_t *val = jl_alloc_something();
  if (some_condition) {
    // We happen to know for complicated external reasons
    // that val is rooted under these conditions
    JL_GC_PROMISE_ROOTED(val);
  }
}
```

## Completeness of analysis

The analyzer only looks at local information.
> 分析装置はローカル情報のみを調べます。
In particular, e.g. in the `PROPAGATES_ROOT` case above, it assumes that such memory is only modified in ways it can see, not in any called functions (unless it happens to decide to consider them in its analysis) and not in any concurrently running threads.
> 特に、 上記の `PROPAGATES_ROOT`のケースでは、このようなメモリは、呼び出される関数ではなく、同時に実行されるスレッドではなく、呼び出される関数でのみ変更されることを前提としています。
As such, it may miss a few problematic cases, though in practice such concurrent modification is fairly rare. Improving the analyzer to handle more such cases may be an interesting topic for future work.
> このように、いくつかの問題のあるケースを見逃してしまう可能性がありますが、実際にはこのような同時修正はかなりまれです。 より多くのそのようなケースを処理するようにアナライザを改良することは、今後の研究にとって興味深い話題になるかもしれません。
