
<!--  Calling C and Fortran Code -->
> # CとFortranコードの呼び出し

<!-- Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran.  -->
> ほとんどのコードはJuliaで書かれていますが、既にCとFortranで書かれた数字のための多くの高品質で成熟したライブラリがあります
<!-- To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions.  -->
> この既存のコードを簡単に使用できるように、JuliaはCおよびFortranの関数を簡単かつ効率的に呼び出すようにします。
Julia has a "no boilerplate" philosophy: functions can be called directly from Julia without any "glue" code, code generation, or compilation -- even from the interactive prompt. 
> Juliaは、「定型句なし」という理念を持っています。関数は、「グルー」コード、コード生成、またはコンパイルなしで、ジュリアから直接呼び出すことができます。
<!-- This is accomplished just by making an appropriate call with [`ccall`](@ref) syntax, which looks like an ordinary function call. -->
> これは、通常の関数呼び出しのように見える [`ccall`](@ref) 構文で適切な呼び出しを行うだけで達成されます。

<!-- The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the `-shared` and `-fPIC` options.  -->
> 呼び出されるコードは、共有ライブラリとして使用可能でなければなりません。ほとんどのCとFortranライブラリはすでに共有ライブラリとしてコンパイルされていますが、GCC(またはClang)を使ってコードをコンパイルする場合は、 `-shared` と`-fPIC` オプションを使う必要があります。
<!-- The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code.  -->
> Juliaの JIT によって生成された機械命令は、ネイティブ C 呼び出しと同じです。その結果、オーバーヘッドは C コードからライブラリ関数を呼び出すのと同じです。
<!-- (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions.  -->
> ( C とJuliaの両方で非ライブラリ関数呼び出しをインライン化することができるため、共有ライブラリ関数呼び出しよりもオーバーヘッドが少なくなる可能性があります。
<!-- When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that.  -->
> ライブラリと実行可能ファイルの両方が LLVM によって生成されると、この境界を越えて最適化することもできる全体プログラム最適化を実行することは可能ですが、Juliaはこれをまだサポートしていません。
<!-- In the future, however, it may do so, yielding even greater performance gains.) -->
> しかし、将来的にはパフォーマンスが向上する可能性があります。

Shared libraries and functions are referenced by a tuple of the form `(:function, "library")` or `("function", "library")` where `function` is the C-exported function name. 
> 共有ライブラリと関数は `(:function,"library")` または `("function","library")` の形式のタプルによって参照されます。 `function`はCでエクスポートされた関数名です。
`library` refers to the shared library name: shared libraries available in the (platform-specific) load path will be resolved by name, and if necessary a direct path may be specified.
> `library`は共有ライブラリ名を参照します。(プラットフォーム固有の)ロードパスで利用可能な共有ライブラリは名前で解決され、必要に応じてダイレクトパスが指定されます。

<!-- <!--  function name may be used alone in place of the tuple (just `:function` or `"function"`).  --> -->
> 関数名はタプルの代わりに単独で使用できます(`:function` または `"function"`)。
<!-- In this case the name is resolved within the current process.  -->
> この場合、名前は現在のプロセス内で解決されます。
<!-- This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia. -->
> このフォームは、C ライブラリ関数、Juliaランタイムの関数、またはJuliaにリンクされたアプリケーションの関数を呼び出すために使用できます。

By default, Fortran compilers [generate mangled names](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via [`ccall`](@ref) you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler.  
> デフォルトでは、Fortranのコンパイラは、(例えば、関数名を小文字または大文字に変換し、しばしばアンダースコアを付加して)変換された名前を生成します(https://en.wikipedia.org/wiki/Name_mangling#Fortran)。 Fortran関数を [`ccall`](@ref) で実行する場合は、Fortran コンパイラが従うルールに対応するマングルされた識別子を渡す必要があります。
<!-- Also, when calling a Fortran function, all inputs must be passed by reference. -->
> また、Fortran関数を呼び出すときは、すべての入力を参照渡しする必要があります。

<!-- Finally, you can use [`ccall`](@ref) to actually generate a call to the library function.  -->
> 最後に、[`ccall`](@ref) を使って実際にライブラリ関数を呼び出すことができます。
<!-- Arguments to [`ccall`](@ref) are as follows: -->
> [`ccall`](@ref) の引数は次のとおりです：



<!-- 1. A `(:function, "library")` pair, which must be written as a literal constant, -->
> 1.リテラル定数として記述しなければならない `(:function、"library")` の組
<!-- >    OR -->
    OR

<!-- >   a function pointer (for example, from `dlsym`). -->
    > 関数ポインタ(例えば、 `dlsym`から)

<!-- 2. Return type (see below for mapping the declared C type to Julia) -->
> 2.戻り値の型(宣言されたC型をJuliaにマッピングする方法については以下を参照)

<!-- >   * This argument will be evaluated at compile-time, when the containing method is defined. -->
   > * この引数は、包含メソッドが定義されているコンパイル時に評価されます。

<!-- 3. A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression. -->
> 3.入力タイプのタプル。 入力型は、タプル値の変数や式ではなく、リテラルのタプルとして記述する必要があります。

<!-- >   * This argument will be evaluated at compile-time, when the containing method is defined. -->
   > * この引数は、包含メソッドが定義されているコンパイル時に評価されます。

<!-- 4. The following arguments, if any, are the actual argument values passed to the function. -->
> 4.以下の引数があれば、関数に渡される実際の引数値です。

<!-- As a complete but simple example, the following calls the `clock` function from the standard C library: -->
> 完全ではあるが単純な例として、以下は標準のCライブラリから `clock` 関数を呼び出します:

```julia-repl
julia> t = ccall((:clock, "libc"), Int32, ())
2292761

julia> t
2292761

julia> typeof(ans)
Int32
```

<!-- `clock` takes no arguments and returns an [`Int32`](@ref).  -->
> `clock` は引数をとらず、[`Int32`](@ref) を返します。
<!-- One common gotcha is that a 1-tuple must be written with a trailing comma.  -->
> 1つのよくある問題は、1タプルは末尾のカンマで書かれなければならないということです。
<!-- For example, to call the `getenv` function to get a pointer to the value of an environment variable, one makes a call like this: -->
> たとえば、 `getenv` 関数を呼び出して環境変数の値へのポインタを取得するには、次のような呼び出しを行います。

```julia-repl
julia> path = ccall((:getenv, "libc"), Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia> unsafe_string(path)
"/bin/bash"
```

<!-- Note that the argument type tuple must be written as `(Cstring,)`, rather than `(Cstring)`.  -->
> 引数型タプルは `(Cstring)` ではなく `(Cstring,)` として記述しなければならないことに注意してください。
<!-- This is because `(Cstring)` is just the expression `Cstring` surrounded by parentheses, rather than a 1-tuple containing `Cstring`: -->
> これは、 `(Cstring)` は `Cstring` を含む1つのタプルではなく、カッコで囲まれた `Cstring` という式にすぎないからです：

```jldoctest
julia> (Cstring)
Cstring

julia> (Cstring,)
(Cstring,)
```

In practice, especially when providing reusable functionality, one generally wraps [`ccall`](@ref) uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. 
> 実際には、特に再利用可能な機能を提供する場合、引数を設定するJulia関数で [`ccall`](@ref) の使用を包括し、C や Fortran 関数がどのような方法でエラーをチェックしてJulia呼び出し元に伝播する 例外として
This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. 
> これは、CおよびFortran APIがエラー状態をどのように示しているかについて悪名を持って矛盾しているので、特に重要です。
For example, the `getenv` C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from [`env.jl`](https://github.com/JuliaLang/julia/blob/master/base/env.jl):
> 例えば、 `getenv`Cライブラリ関数は以下のJulia関数にラップされます。これは[` env.jl`](https://github.com/JuliaLang/julia/blob/)からの実際の定義を簡略化したものです。 master / base / env.jl)：

```julia
function getenv(var::AbstractString)
    val = ccall((:getenv, "libc"),
                Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    unsafe_string(val)
end
```

<!-- The C `getenv` function indicates an error by returning `NULL`, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. -->
> Cの `getenv` 関数は `NULL` を返すことによってエラーを示しますが、他の標準のC関数は、-1、0、1などの特殊な値を返すなど、さまざまな方法でエラーを示します。
<!-- This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable: -->
> このラッパーは、呼び出し元が存在しない環境変数を取得しようとすると、問題を明確に示す例外をスローします。

```julia-repl
julia> getenv("SHELL")
"/bin/bash"

julia> getenv("FOOBAR")
getenv: undefined variable: FOOBAR
```

<!-- Here is a slightly more complex example that discovers the local machine's hostname: -->
> 次に、ローカルマシンのホスト名を検出する少し複雑な例を示します。

```julia
function gethostname()
    hostname = Vector{UInt8}(128)
    ccall((:gethostname, "libc"), Int32,
          (Ptr{UInt8}, Csize_t),
          hostname, sizeof(hostname))
    hostname[end] = 0; # ensure null-termination
    return unsafe_string(pointer(hostname))
end
```

This example first allocates an array of bytes, then calls the C library function `gethostname` to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. 
> この例では、最初にバイト配列を割り当て、Cライブラリ関数 `gethostname` を呼び出してホスト名で配列を埋め、ホスト名バッファへのポインタをとり、それが NULL であると仮定してポインタをJulia文字列に変換します 終わりのC文字列。
It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. 
> Cライブラリでは、呼び出し元に呼び出し先に渡され、書き込まれるメモリを割り当てるよう要求するこのパターンを使用するのが一般的です。
<!-- Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. -->
> このようなJuliaからのメモリの割り当ては、通常、初期化されていない配列を作成し、そのデータへのポインタをC関数に渡すことによって行われます。
<!-- This is why we don't use the `Cstring` type here: as the array is uninitialized, it could contain NUL bytes.  -->
> このため、ここでは `Cstring` 型を使用しません：配列が初期化されていないため、NULバイトを含む可能性があります。
<!-- Converting to a `Cstring` as part of the [`ccall`](@ref) checks for contained NUL bytes and could therefore throw a conversion error. -->
> [`ccall`](@ref) の一部として `Cstring` に変換すると、含まれている NUL バイトがチェックされ、変換エラーが発生する可能性があります。

<!-- ## Creating C-Compatible Julia Function Pointers -->
> ## C互換Julia関数ポインタの作成

<!-- It is possible to pass Julia functions to native C functions that accept function pointer arguments. -->
> 関数ポインタ引数を受け入れるネイティブC関数にJulia関数を渡すことは可能です。
<!-- For example, to match C prototypes of the form: -->
> たとえば、次の形式のCプロトタイプを一致させるには：

```c
typedef returntype (*functiontype)(argumenttype,...)
```

<!-- The function [`cfunction()`](@ref) generates the C-compatible function pointer for a call to a Julia function.  -->
> 関数 [`cfunction()`](@ref) は、Julia関数への呼び出しのためにC互換の関数ポインタを生成します。
<!-- Arguments to [`cfunction()`](@ref) are as follows: -->
> [`cfunction()`](@ref) の引数は次のとおりです：

<!-- 1. A Julia Function -->
> 1. Julia 関数
<!-- 2. Return type -->
> 2. 戻り値の型
<!-- 3. A tuple of input types -->
> 3. 入力タイプのタプル


<!-- Only platform-default C calling convention is supported.  -->
> プラットフォームのデフォルトのC呼び出し規約のみがサポートされています。
`cfunction`-generated pointers cannot be used in calls where WINAPI expects `stdcall` function on 32-bit windows, but can be used on WIN64 (where `stdcall` is unified with C calling convention).
> `cfunction` 生成ポインタはWINAPIが32ビットウィンドウで `stdcall` 関数を期待している呼び出しでは使用できませんが、WIN64では `stdcall` がC呼び出し規約で統一されています。

<!-- A classic example is the standard C library `qsort` function, declared as: -->
> 典型的な例は、標準Cライブラリ `qsort` 関数です。これは次のように宣言されています:

```c
void qsort(void *base, size_t nmemb, size_t size,
           int(*compare)(const void *a, const void *b));
```

<!-- The `base` argument is a pointer to an array of length `nmemb`, with elements of `size` bytes each.  -->
> `base` 引数は長さ `nmemb` の配列へのポインタで、 `size` バイトの要素がそれぞれあります。
<!-- `compare` is a callback function which takes pointers to two elements `a` and `b` and returns an integer less/greater than zero if `a` should appear before/after `b` (or zero if any order is permitted).  -->
> `compare` は2つの要素 `a` と `b` へのポインタをとり、`b` の前後に `a` が現れる場合は0より小さい整数を返すコールバック関数です(順序が許される場合は0) 。
Now, suppose that we have a 1d array `A` of values in Julia that we want to sort using the `qsort` function (rather than Julia's built-in `sort` function). 
> ここで、Juliaの `qsort`関数(Juliaの組み込み` sort`関数ではなく)を使ってソートしたい値の1次元配列 `A`があるとします。
<!-- Before we worry about calling `qsort` and passing arguments, we need to write a comparison function that works for some arbitrary type T: -->
> `qsort` を呼び出して引数を渡すことを心配する前に、任意の型 T で動作する比較関数を書く必要があります：

```jldoctest mycompare
julia> function mycompare(a::T, b::T) where T
           return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint
       end
mycompare (generic function with 1 method)
```

Notice that we have to be careful about the return type: `qsort` expects a function returning a C `int`, so we must be sure to return `Cint` via a call to `convert` and a `typeassert`.
> `qsort` は `int` を返す関数を期待しているので、 `convert` と `typeassert` を呼び出して `Cint` を返す必要があることに注意してください。

<!-- In order to pass this function to C, we obtain its address using the function `cfunction`: -->
> この関数をCに渡すために、関数 `cfunction` を使ってそのアドレスを取得します：

```jldoctest mycompare
julia> const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));
```

<!-- [`cfunction()`](@ref) accepts three arguments: the Julia function (`mycompare`), the return type (`Cint`), and a tuple of the argument types, in this case to sort an array of `Cdouble` ([`Float64`](@ref)) elements. -->
> [`cfunction()`](@ref) は3つの引数を受け取ります, Julia関数 (`mycompare`) 、戻り値の型 (`Cint`) 、および引数型のタプルです,この例の場合 `Cdouble` ([`Float64`](@ref)) 要素の配列をソートします。

<!-- The final call to `qsort` looks like this: -->
> `qsort` の最後の呼び出しは次のようになります：

```jldoctest mycompare
julia> A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia> ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia> A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4
```

<!-- As can be seen, `A` is changed to the sorted array `[-2.7, 1.3, 3.1, 4.4]`.  -->
> 見て分かるように、 `A` はソートされた配列 `[-2.7,1.3,3.1,4.4]` に変更されます。
<!-- Note that Julia knows how to convert an array into a `Ptr{Cdouble}`, how to compute the size of a type in bytes (identical to C's `sizeof` operator), and so on.  -->
> Juliaは、配列を `Ptr{Cdouble}` に変換する方法、バイトの型のサイズを計算する方法 (C の `sizeof` 演算子と同じ) などを知っていることに注意してください。
For fun, try inserting a `println("mycompare($a,$b)")` line into `mycompare`, which will allow you to see the comparisons that `qsort` is performing (and to verify that it is really calling the Julia function that you passed to it).
> 楽しみのために `println("mycompare($a,$b)")` 行を `mycompare` に挿入してください。`qsort` が実行している比較を見ることができます。(あなたが渡したJulia関数)。

<!-- ## Mapping C Types to Julia -->
> ## C型をJuliaにマッピングする

It is critical to exactly match the declared C type with its declaration in Julia. 
> Juliaで宣言されたC型とその宣言を正確に一致させることが重要です。
Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.
> 不一致により、あるシステムで正常に動作するコードが失敗したり、別のシステムで不確定な結果が生じることがあります。

Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. 
> C関数を呼び出す過程では、Cヘッダーファイルは使用されないことに注意してください。Juliaの型と呼び出しシグネチャがCヘッダーファイルのものを正確に反映するようにする責任があります。
(The [Clang package](https://github.com/ihnorton/Clang.jl) can be used to auto-generate Julia code from a C header file.)
> ([Clangパッケージ](https://github.com/ihnorton/Clang.jl)は、CヘッダーファイルからJuliaコードを自動生成するために使用できます)。

### Auto-conversion:
> ### 自動変換：

Julia automatically inserts calls to the [`Base.cconvert()`](@ref) function to convert each argument to the specified type. 
> Juliaは自動的に[`Base.convert()`](@ref)関数への呼び出しを挿入し、各引数を指定された型に変換します。
For example, the following call:
> たとえば、次の呼び出しを行います。

```julia
ccall((:foo, "libfoo"), Void, (Int32, Float64), x, y)
```

will behave as if the following were written:

```julia
ccall((:foo, "libfoo"), Void, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))
```

[`Base.cconvert()`](@ref) normally just calls [`convert()`](@ref), but can be defined to return an arbitrary new object more appropriate for passing to C.
> [`Base.cconvert()`](@ref)は通常 `[convert()`](@ref)を呼び出すだけですが、Cに渡すより適切な任意の新しいオブジェクトを返すように定義できます。
This should be used to perform all allocations of memory that will be accessed by the C code.
> これは、Cコードによってアクセスされるメモリのすべての割り当てを実行するために使用する必要があります。
For example, this is used to convert an `Array` of objects (e.g. strings) to an array of pointers.
> 例えば、これは、オブジェクトの「配列」(例えば、文字列)をポインタの配列に変換するために使用される。
[`Base.unsafe_convert()`](@ref) handles conversion to `Ptr` types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.
> [`Base.unsafe_convert()`](@ref)は `Ptr`型への変換を処理します。 オブジェクトをネイティブポインタに変換すると、ガベージコレクタからオブジェクトが隠され、早期に解放されるため、安全でないとみなされます。

### Type Correspondences:
> ### タイプ対応：

First, a review of some relevant Julia type terminology:
> まず、関連するJuliaタイプの用語の見直し：

| Syntax / Keyword        | Example                                     | 
                            Description
|
|:------------------------|:-------------------------------------------|
                           :---------------------------------------------------------------------------------
|
| `mutable struct`        | `String`                                   | 
                            "Leaf Type" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. 
                            The type parameters of a leaf type must be fully defined (no `TypeVars` are allowed) in order for the instance to be constructed.
|
| `abstract type`         | `Any`, `AbstractArray{T, N}`, `Complex{T}` | 
                            "Super Type" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.
|
| `T{A}`                  | `Vector{Int}`                              | 
                            "Type Parameter" :: A specialization of a type (typically used for dispatch or storage optimization).
|
|                         |                                            | 
                            "TypeVar" :: The `T` in the type parameter declaration is referred to as a TypeVar (short for type variable).
|
| `primitive type`        | `Int`, `Float64`                           | 
                            "Primitive Type" :: A type with no fields, but a size. 
                            It is stored and defined by-value.
|
| `struct`                | `Pair{Int, Int}`                           | 
                            "Struct" :: A type with all fields defined to be constant. 
                            It is defined by-value, and may be stored with a type-tag.
|
|                         | `Complex128` (`isbits`)                    | 
                            "Is-Bits"   :: A `primitive type`, or a `struct` type where all fields are other `isbits` types. 
                            It is defined by-value, and is stored without a type-tag.
|
| `struct ...; end`       | `nothing`                                  | 
                            "Singleton" :: a Leaf Type or Struct with no fields.
|
| `(...)` or `tuple(...)` | `(1, 2, 3)`                                |
                            "Tuple" :: an immutable data-structure similar to an anonymous struct type, or a constant array. 
                            Represented as either an array or a struct.
                                                                        |
### Bits Types:
> ### ビットの種類：

There are several special types to be aware of, as no other type can be defined to behave the same:
> 同じように振る舞うように他の型を定義することはできないので、注意すべきいくつかの特別な型があります：

  * `Float32`
    Exactly corresponds to the `float` type in C (or `REAL*4` in Fortran).
    > Cの `float`型(Fortranの` REAL * 4`)とまったく同じです。

  * `Float64`
    Exactly corresponds to the `double` type in C (or `REAL*8` in Fortran).
    > C言語の `double '型(Fortranの` REAL * 8`)とまったく同じです。

  * `Complex64`
    Exactly corresponds to the `complex float` type in C (or `COMPLEX*8` in Fortran).
    > C言語の `complex float`型(Fortranの` COMPLEX * 8`)とまったく同じです。

* `Complex128`
   Exactly corresponds to the `complex double` type in C (or `COMPLEX*16` in Fortran).
    > C言語の `` complex double`(Fortranの `COMPLEX * 16`)とまったく同じです。

* `Signed`
    Exactly corresponds to the `signed` type annotation in C (or any `INTEGER` type in Fortran).
    > C言語の `signed '型アノテーション(またはFortranの` INTEGER`型)に完全に対応しています。
    Any Julia type that is not a subtype of [`Signed`](@ref) is assumed to be unsigned.
    > [`Signed`](@ref)のサブタイプではない任意のJulia型は、符号なしとみなされます。

* `Ref{T}`

    Behaves like a `Ptr{T}` that can manage its memory via the Julia GC.
    > Julia GC経由でメモリを管理できる `Ptr {T} 'のように動作します。

* `Array{T,N}`
> * `配列{T、N}`

   When an array is passed to C as a `Ptr{T}` argument, it is not reinterpret-cast: 
   Julia requires that the element type of the array matches `T`, and the address of the first element is passed.
   > 配列が `Ptr {T}`引数としてCに渡されるとき、reinterpret-castは実行されません:
   > Juliaは、配列の要素型が `T`にマッチし、最初の要素のアドレスが渡されることを要求します。

   Therefore, if an `Array` contains data in the wrong format, it will have to be explicitly converted using a call such as `trunc(Int32, a)`.
   > したがって、 `Array`に間違った形式のデータが含まれていると、` trunc(Int32、a) `のような呼び出しを使って明示的に変換する必要があります。

   To pass an array `A` as a pointer of a different type *without* converting the data beforehand (for example, to pass a `Float64` array to a function that operates on uninterpreted bytes), you can declare the argument as `Ptr{Void}`.
   > 配列 `A`を別の型のポインタとして*渡す前に(例えば、` Float64`配列を未解釈のバイトで動作する関数に渡すため)、引数を `Ptr {無効}。

   If an array of eltype `Ptr{T}` is passed as a `Ptr{Ptr{T}}` argument, [`Base.cconvert()`](@ref) will attempt to first make a null-terminated copy of the array with each element replaced by its [`Base.cconvert()`](@ref) version. 
   > eltypeの配列 `Ptr {T}}が` Ptr {Ptr {T}} `引数として渡された場合、[` Base.cconvert() `](@ref)は、各要素がその `` Base.cconvert() `](@ref)バージョンに置き換えられた配列。
   This allows, for example, passing an `argv` pointer array of type `Vector{String}` to an argument of type `Ptr{Ptr{Cchar}}`.
   > これは、例えば、 `Vector {String} '型の` argv`ポインタ配列を `Ptr {Ptr {Cchar}}`型の引数に渡すことを可能にします。

On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. 
> 現在サポートしているすべてのシステムで、基本 C/C++ 値の型は次のようにJulia型に変換されます。
Every C type also has a corresponding Julia type with the same name, prefixed by C.
> すべてのCタイプには、対応する同じ名前のJuliaタイプがあり、接頭辞はCです。
This can help for writing portable code (and remembering that an `int` in C is not the same as an `Int` in Julia).
> これは、移植可能なコードを書くのに役立ちます(そして、Cの `int`はJuliaの` Int`と同じではないことを思い出してください)。


**System Independent:**

| C name                             | Fortran name             | Standard Julia Alias |  Julia Base Type   |
|:---------------------------------- |:------------------------ |:-------------------- |:------------------ |
| `unsigned char`                    | `CHARACTER`              | `Cuchar`             | `UInt8`            |
:---------------------------------------------------------------------------------------------------------- |
| `bool` (only in C++)               |                          | `Cuchar`             | `UInt8`            |
:---------------------------------------------------------------------------------------------------------- |
| `short`                            | `INTEGER*2`, `LOGICAL*2` | `Cshort`             | `Int16`            |
:---------------------------------------------------------------------------------------------------------- |
| `unsigned short`                   |                          | `Cushort`            | `UInt16`           |
:---------------------------------------------------------------------------------------------------------- |
| `int`, `BOOL` (C, typical)         | `INTEGER*4`, `LOGICAL*4` | `Cint`               | `Int32`            |
:---------------------------------------------------------------------------------------------------------- |
| `unsigned int`                     |                          | `Cuint`              | `UInt32`           |
:---------------------------------------------------------------------------------------------------------- |
| `long long`                        | `INTEGER*8`, `LOGICAL*8` | `Clonglong`          | `Int64`            |
:---------------------------------------------------------------------------------------------------------- |
| `unsigned long long`               |                          | `Culonglong`         | `UInt64`           |
:---------------------------------------------------------------------------------------------------------- |
| `intmax_t`                         |                          | `Cintmax_t`          | `Int64`            |
:---------------------------------------------------------------------------------------------------------- |
| `uintmax_t`                        |                          | `Cuintmax_t`         | `UInt64`           |
:---------------------------------------------------------------------------------------------------------- |
| `float`                            | `REAL*4i`                | `Cfloat`             | `Float32`          |
:---------------------------------------------------------------------------------------------------------- |
| `double`                           | `REAL*8`                 | `Cdouble`            | `Float64`          |
:---------------------------------------------------------------------------------------------------------- |
| `complex float`                    | `COMPLEX*8`              | `Complex64`          | `Complex{Float32}` |
:---------------------------------------------------------------------------------------------------------- |
| `complex double`                   | `COMPLEX*16`             | `Complex128`         | `Complex{Float64}` |
:---------------------------------------------------------------------------------------------------------- |
| `ptrdiff_t`                        |                          | `Cptrdiff_t`         | `Int`              |
:---------------------------------------------------------------------------------------------------------- |
| `ssize_t`                          |                          | `Cssize_t`           | `Int`              |
:---------------------------------------------------------------------------------------------------------- |
| `size_t`                           |                          | `Csize_t`            | `UInt`             |
:---------------------------------------------------------------------------------------------------------- |
| `void`                             |                          |                      | `Void`             |
:---------------------------------------------------------------------------------------------------------- |
| `void` and `[[noreturn]]` or `_Noreturn`   |                  |                      | `Union{}`          |
:---------------------------------------------------------------------------------------------------------- |
| `void*`                            |                          |                      | `Ptr{Void}`        |
:---------------------------------------------------------------------------------------------------------- |
| `T*` (where T represents an appropriately defined type) |     |                      | `Ref{T}`           |
:---------------------------------------------------------------------------------------------------------- |
| `char*` (or `char[]`, e.g. a string)  | `CHARACTER*N`         |                      | `Cstring` 
                                                                                        if NUL-terminated,
                                                                                        or `Ptr{UInt8}` 
                                                                                        if not              |
:---------------------------------------------------------------------------------------------------------- |
| `char**` (or `*char[]`)            |                          |                      | `Ptr{Ptr{UInt8}}`  |
:---------------------------------------------------------------------------------------------------------- |
| `jl_value_t*` (any Julia Type)     |                          |                      | `Any`              |
:---------------------------------------------------------------------------------------------------------- |
| `jl_value_t**` (a reference to a Julia Type)            |     |                      | `Ref{Any}`         |
:---------------------------------------------------------------------------------------------------------- |
| `va_arg`                           |                          |                      | Not supported      |
:---------------------------------------------------------------------------------------------------------- |
| `...` (variadic function specification)                 |                          |                      |
                                                   `T...` (where `T` is one of the above types, variadic functions of different argument types are not supported) |
:---------------------------------------------------------------------------------------------------------- |

The `Cstring` type is essentially a synonym for `Ptr{UInt8}`, except the conversion to `Cstring` throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  
> `Cstring`型は基本的に` Ptr {UInt8} `と同義ですが、` Cstring`への変換は、Julia文字列に埋め込みNUL文字が含まれているとエラーをスローします(Cルーチン ターミネーターとしてNULを扱います)。
If you are passing a `char*` to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use `Ptr{UInt8}` as the argument type. 
> (例えば、明示的な文字列長を渡すなどして)NUL終了を想定していないCルーチンに `char *`を渡している場合や、Julia文字列にNULが含まれていないことが分かっていて、 `Ptr {UInt8}`を引数の型として使うことができます。
`Cstring` can also be used as the [`ccall`](@ref) return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.
> `Cstring`も[` ccall`](@ref)の戻り値の型として使うことができますが、その場合は余分なチェックを導入せず、呼び出しの可読性を向上させることだけを目的としています。

**System-dependent:**
> ** システム依存: **

| C name          | Standard Julia Alias | Julia Base Type                              |
|:--------------- |:-------------------- |:-------------------------------------------- |
| `char`          | `Cchar`              | `Int8` (x86, x86_64), `UInt8` (powerpc, arm) |
| `long`          | `Clong`              | `Int` (UNIX), `Int32` (Windows)              |
| `unsigned long` | `Culong`             | `UInt` (UNIX), `UInt32` (Windows)            |
| `wchar_t`       | `Cwchar_t`           | `Int32` (UNIX), `UInt16` (Windows)           |

#!!! note
   When calling a Fortran function, all inputs must be passed by reference, so all type correspondences above should contain an additional `Ptr{..}` or `Ref{..}` wrapper around their type specification.
   > Fortran関数を呼び出すときは、すべての入力を参照渡しする必要があります。したがって、上記のすべての型の対応には、型指定の周りに追加の `Ptr {..}`または `Ref {..} 'ラッパーを含める必要があります。

!!! warning
  For string arguments (`char*`) the Julia type should be `Cstring` (if NUL- terminated data is expected) or either `Ptr{Cchar}` or `Ptr{UInt8}` otherwise (these two pointer types have the same effect), as described above, not `String`. 
  > 文字列引数( `char *`)の場合、Julia型は `Cstring`(NUL終了データが必要な場合)または` Ptr {Cchar} `または` Ptr {UInt8} `でなければなりません。エフェクト)を使用します。
  Similarly, for array arguments (`T[]` or `T*`), the Julia type should again be `Ptr{T}`, not `Vector{T}`.
  > 同様に、配列引数( `T []`や `T *`)では、Julia型は `Vector {T}`ではなく `Ptr {T}`でなければなりません。

!!! warning
   Julia's `Char` type is 32 bits, which is not the same as the wide character type (`wchar_t` or `wint_t`) on all platforms.
   > Juliaの `Char`タイプは32ビットです。これは、すべてのプラットフォームでワイド文字タイプ(` wchar_t`または `wint_t`)と同じではありません。

!!! warning
   A return type of `Union{}` means the function will not return i.e. C++11 `[[noreturn]]` or C11 `_Noreturn` (e.g. `jl_throw` or `longjmp`). 
   > 戻り値の型が `Union {} 'の場合、関数はC ++ 11` [[noreturn]]やC11 `_Noreturn`(例えば` jl_throw`や `longjmp`)を返しません。
   Do not use this for functions that return no value (`void`) but do return, use `Void` instead.
   > 値を返さない関数( `void`)ではこれを使用しないでください。代わりに` Void`を使用して戻ります。

!!! note
   For `wchar_t*` arguments, the Julia type should be `Cwstring` (if the C routine expects a NUL-terminated string) or `Ptr{Cwchar_t}` otherwise. 
   > `wchar_t *`引数の場合、Julia型は `Cwstring`(CルーチンがNUL終止文字列を期待する場合)または` Ptr {Cwchar_t} `でなければなりません。
   Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the `Cwstring` type will cause an error to be thrown if the string itself contains NUL characters).
   > JuliaのUTF-8文字列データは内部的にNUL終端されているので、コピーを行わずにNUL終端データが必要なC関数に渡すことができます(ただし、 `Cwstring`型を使用するとエラーがスローされます。文字列自体にNUL文字が含まれています)。

!!! note
   C functions that take an argument of the type `char**` can be called by using a `Ptr{Ptr{UInt8}}` type within Julia. 
   > `char **`型の引数をとるC関数は、Julia内で `Ptr {Ptr {UInt8}}`型を使って呼び出すことができます。
   For example, C functions of the form:
   > たとえば、次の形式のC関数：

    ```c
    int main(int argc, char **argv);
    ```

   can be called via the following Julia code:
   > 次のジュリアコードで呼び出すことができます：

    ```julia
    argv = [ "a.out", "arg1", "arg2" ]
    ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)
    ```

!!! note
   A C function declared to return `Void` will return the value `nothing` in Julia.
   > `Void`を返すように宣言されたC関数は、Juliaの値に` nothing`を返します。

### Struct Type correspondences
> ### 構造タイプの対応

Composite types, aka `struct` in C or `TYPE` in Fortran90 (or `STRUCTURE` / `RECORD` in some variants of F77), can be mirrored in Julia by creating a `struct` definition with the same field layout.
> Fortran90のC言語の `struct '(構造体)やFortran90の` TYPE`(あるいはF77のいくつかの変形例では `STRUCTURE` /` RECORD`)は、同じフィールドレイアウトを持つ `struct`定義を作成することでJuliaに反映させることができます。

When used recursively, `isbits` types are stored inline. All other types are stored as a pointer to the data. 
> 再帰的に使用される場合、 `isbits`型はインラインで格納されます。他のすべての型は、データへのポインタとして格納されます。
When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. 
> Cの別の構造体のby-valueで使用されている構造体をミラーリングするときは、正しいフィールドの位置合わせを保持しないため、フィールドを手動でコピーしないでください。
Instead, declare an `isbits` struct type and use that instead. 
> 代わりに、 `isbits`構造体型を宣言し、代わりにそれを使用してください。
Unnamed structs are not possible in the translation to Julia.
> Juliaへの翻訳では、無名の構造体は使用できません。

Packed structs and union declarations are not supported by Julia.
> パッキングされた構造体と共用体宣言はJuliaではサポートされていません。

You can get a near approximation of a `union` if you know, a priori, the field that will have the greatest size (potentially including padding). 
> 先験的に、最大サイズ(潜在的にパディングを含む)を持つフィールドが分​​かっている場合は、 `union 'の近似値を近似することができます。
When translating your fields to Julia, declare the Julia field to be only of that type.
> あなたのフィールドをJuliaに翻訳するときは、Juliaフィールドをそのタイプだけに宣言してください。

Arrays of parameters can be expressed with `NTuple`:
> パラメータの配列は `NTuple`で表現できます：

```
in C:
struct B {
    int A[3];
};
b_a_2 = B.A[2];

in Julia:
struct B
    A::NTuple{3, CInt}
end
b_a_2 = B.A[3]  
                # note the difference in indexing (1-based in Julia, 0-based in C)
                > #インデックスの違いに注意してください(Juliaは1、Cは0を基準にしています)
```

Arrays of unknown size (C99-compliant variable length structs specified by `[]` or `[0]`) are not directly supported. 
> サイズが不明な配列( `[]`または `[0]`で指定されたC99準拠の可変長構造体)は直接サポートされていません。
Often the best way to deal with these is to deal with the byte offsets directly.
> 多くの場合、これらを処理する最善の方法はバイトオフセットを直接処理することです。
For example, if a C library declared a proper string type and returned a pointer to it:
> たとえば、Cライブラリが適切な文字列型を宣言し、ポインタを返した場合は、次のようになります。

```c
struct String {
    int strlen;
    char data[];
};
```

In Julia, we can access the parts independently to make a copy of that string:
> Juliaでは、その文字列のコピーを作成するために、パーツに個別にアクセスできます。

```julia
str = from_c::Ptr{Void}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)
```

### Type Parameters
> ### 型パラメータ

The type arguments to `ccall` are evaluated statically, when the method containing the ccall is defined.
> `ccall`の型引数は、ccallを含むメソッドが定義されているときに静的に評価されます。
They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.
> したがって、変数ではなく、リテラルタプルの形をとる必要があり、ローカル変数を参照することはできません。

This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.
> これは奇妙な制限のように聞こえるかもしれませんが、CはJuliaのような動的言語ではないので、その関数は静的に既知の固定シグネチャで引数型を受け入れることができます。

However, while the type layout must be known statically to compute the `ccall` ABI, the static parameters of the function are considered to be part of this static environment.
> しかし、 `ccall` ABIを計算するために型のレイアウトを静的に知らなければならないが、関数の静的パラメータはこの静的環境の一部であると考えられる。
The static parameters of the function may be used as type parameters in the `ccall` signature, as long as they don't affect the layout of the type.
> 関数の静的パラメータは、型のレイアウトに影響を与えない限り、 `ccall`シグネチャの型パラメータとして使用できます。
For example, `f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)` is valid, since `Ptr` is always a word-size primitive type.
> たとえば、 `Ptr`は常に単語サイズのプリミティブ型なので、`f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)`は有効です。
But, `g(x::T) where {T} = ccall(:notvalid, T, (T,), x)` is not valid, since the type layout of `T` is not known statically.
> しかし、 `T`の型レイアウトが静的に知られていないので、` g(x :: T){T} = ccall(：notvalid、T、(T、)、x) `は有効ではありません。

### SIMD Values
> ### SIMD値

Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.
> 注：この機能は現在、64ビットx86およびAArch64プラットフォームでのみ実装されています。

If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of `VecElement` that naturally maps to the SIMD type.  
> C / C ++ルーチンにネイティブSIMD型の引数または戻り値がある場合、対応するJulia型は自然にSIMD型にマップされる同種の 'VecElement'のタプルです。

Specifically:
> 具体的には：

   * The tuple must be the same size as the SIMD type. For example, a tuple representing an `__m128` on x86 must have a size of 16 bytes.
   > * タプルはSIMD型と同じサイズでなければなりません。 たとえば、 `__m128`を表すタプルのx86のサイズは16バイトでなければなりません。
   * The element type of the tuple must be an instance of `VecElement{T}` where `T` is a primitive type that is 1, 2, 4 or 8 bytes.
   > * タプルの要素型は `VecElement {T}`のインスタンスでなければならず、 `T`はプリミティブ型で1,2,4,8バイトです。

For instance, consider this C routine that uses AVX intrinsics:
> たとえば、AVX組み込み関数を使用するこのCルーチンを考えてみましょう。

c
#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}
```

The following Julia code calls `dist` using `ccall`:

```julia
const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))
```

The host machine must have the requisite SIMD registers.  
> ホストマシンには、SIMDレジスタが必要です。
For example, the code above will not work on hosts without AVX support.
> たとえば、上記のコードはAVXサポートのないホストでは機能しません。

### Memory Ownership
> ### メモリの所有権

**malloc/free**
> ** malloc /free **

Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. 
> このようなオブジェクトのメモリ割り当てと割り当て解除は、Cプログラムの場合と同様に、使用されているライブラリの適切なクリーンアップルーチンへの呼び出しによって処理されなければなりません。
Do not try to free an object received from a C library with `Libc.free` in Julia, as this may result in the `free` function being called via the wrong `libc` library and cause Julia to crash. 
> JuliaでCライブラリから受け取ったオブジェクトを `Libc.free`で解放しようとしないでください。` libc`ライブラリを介して `free`関数が呼び出されると、Juliaがクラッシュする可能性があります。
The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.
> 逆方向(外部ライブラリによって解放されるJuliaで割り当てられたオブジェクトを渡す)も同様に無効です。

### When to use T, Ptr{T} and Ref{T}
> ## T、Ptr {T}とRef {T}を使うとき、

In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type `T` inside the [`ccall`](@ref), as they are passed by value.  
> 外部のCルーチンへの呼び出しを扱うJuliaコードでは、通常の(ポインタでない)データは、値によって渡されるので、[`ccall`](@ref)の内部で` T '型であると宣言されるべきです。
For C code accepting pointers, `Ref{T}` should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to [`Base.cconvert()`](@ref).
> Cコードを受け入れるポインタの場合、入力引数の型には一般に `Ref {T}`を使うべきです。[`Base.cconvert()`の暗黙の呼び出しによってJuliaやCのいずれかで管理されるメモリへのポインタの使用が可能になります。 (@ref)。
In contrast, pointers returned by the C function called should be declared to be of output type `Ptr{T}`, reflecting that the memory pointed to is managed by C only. 
> 対照的に、呼び出されたC関数によって返されるポインタは、出力タイプが `Ptr {T}`であると宣言されなければなりません。
Pointers contained in C structs should be represented as fields of type `Ptr{T}` within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.
> C構造体に含まれるポインタは、対応するC構造体の内部構造を模倣するように設計された対応するJulia構造体型の中で、 `Ptr {T}`型のフィールドとして表現されるべきです。

In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type `Ref{T}`, as Fortran passes all variables by reference. 
> Fortranがすべての変数を参照渡しするので、Juliaコードで外部Fortranルーチンを呼び出す場合、すべての入力引数は `Ref {T}`型として宣言する必要があります。
The return type should either be `Void` for Fortran subroutines, or a `T` for Fortran functions returning the type `T`.
> 戻り値の型は、Fortranサブルーチンの場合は `Void`、` T`型を返すFortran関数の場合は `T`です。

## Mapping C Functions to Julia
> ## C関数をJuliaにマッピングする

### `ccall`/`cfunction` argument translation guide

For translating a C argument list to Julia:

  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,
    `complex`, `enum` or any of their `typedef` equivalents

      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)
      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`
      * argument value will be copied (passed by value)
  * `struct T` (including typedef to a struct)

      * `T`, where `T` is a Julia leaf type
      * argument value will be copied (passed by value)
  * `void*`

      * depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list
      * this argument may be declared as `Ptr{Void}`, if it really is just an unknown pointer
  * `jl_value_t*`

      * `Any`
      * argument value must be a valid Julia object
      * currently unsupported by [`cfunction()`](@ref)
  * `jl_value_t**`

      * `Ref{Any}`
      * argument value must be a valid Julia object (or `C_NULL`)
      * currently unsupported by [`cfunction()`](@ref)
  * `T*`

      * `Ref{T}`, where `T` is the Julia type corresponding to `T`
      * argument value will be copied if it is an `isbits` type otherwise, the value must be a valid Julia
        object
  * `(T*)(...)` (e.g. a pointer to a function)

      * `Ptr{Void}` (you may need to use [`cfunction()`](@ref) explicitly to create this pointer)
  * `...` (e.g. a vararg)

      * `T...`, where `T` is the Julia type
  * `va_arg`

      * not supported

### `ccall`/`cfunction` return type translation guide
### `call` /` function` return型変換ガイド

For translating a C return type to Julia:
> Cの戻り値型をJuliaに変換する場合：

  * `void`

      * `Void` (this will return the singleton instance `nothing::Void`)
      > * `Void` (これはシングルトンインスタンス `nothing :: Void`を返します)
  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`, `complex`, `enum` or any of their `typedef` equivalents
  > * `T`,ここで、 `T 'はプリミティブ型の1つです `int`、` long`、 `short`、` float`、 `double`、` complex`、 `enum`またはそれらの` typedef`等価物のいずれか

      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)
      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`
      * argument value will be copied (returned by-value)
      > * `T`、` T`は同等のJuliaビットタイプです(上記の表を参照)
> * `T`が` enum`の場合、引数の型は `Cint`または` Cuint`と等価でなければなりません
> *引数の値がコピーされます(値によって返されます)

   * `void *`

       * `struct T` (including typedef to a struct)
       > * `struct T`(構造体へのtypedefを含む)

       * `T`, where `T` is a Julia Leaf Type
       > * `T`、` T`はジュリアリーフタイプです
       * argument value will be copied (returned by-value)
       > * 引数の値がコピーされます(値によって返されます)
   * `void*`

       * depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list
       > * このパラメータがどのように使用されるかによって異なりますが、最初にこれを目的のポインタ型に変換し、このリストの残りの規則を使用してJuliaの等価物を決定します
       * this argument may be declared as `Ptr{Void}`, if it really is just an unknown pointer
       > * この引数は実際には未知のポインタの場合は `Ptr {Void}`として宣言することができます
  * `jl_value_t*`

      * `Any`
      * argument value must be a valid Julia object
      > * 引数の値は有効なJuliaオブジェクトでなければなりません
  * `jl_value_t**`

      * `Ref{Any}`
      * argument value must be a valid Julia object (or `C_NULL`)
      > * 引数の値は有効なJuliaオブジェクトでなければなりません(or `C_NULL`)
    * `T*`

       * If the memory is already owned by Julia, or is an `isbits` type, and is known to be non-null:
       > * メモリがJuliaによって既に所有されているか、 `isbits`型であり、nullでないことが分かっている場合：

          * `Ref{T}`, where `T` is the Julia type corresponding to `T`
          * a return type of `Ref{Any}` is invalid, it should either be `Any` (corresponding to `jl_value_t*`) or `Ptr{Any}` (corresponding to `Ptr{Any}`)
          * C **MUST NOT** modify the memory returned via `Ref{T}` if `T` is an `isbits` type
      * If the memory is owned by C:

          * `Ptr{T}`, where `T` is the Julia type corresponding to `T`

  * `(T*)(...)` (e.g. a pointer to a function)
  > * `(T*)(...)` (e.g. 関数へのポインタ)

      * `Ptr{Void}` (you may need to use [`cfunction()`](@ref) explicitly to create this pointer)
      > * `Ptr{Void}` (このポインタを作成するために明示的に[`cfunction()`](@ref) を使う必要があるかもしれません)

### Passing Pointers for Modifying Inputs
> ### 入力を変更するためのポインタの受け渡し

Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. 
> Cは複数の戻り値をサポートしていないので、C関数は多くの場合、関数が変更するデータへのポインタを取ります。
To accomplish this within a [`ccall`](@ref), you need to first encapsulate the value inside an `Ref{T}` of the appropriate type. 
> [`ccall`](@ref)内でこれを達成するには、適切な型の` Ref {T} `の中に値をカプセル化する必要があります。
When you pass this `Ref` object as an argument, Julia will automatically pass a C pointer to the encapsulated data:
> この `Ref`オブジェクトを引数として渡すと、Juliaはカプセル化されたデータに自動的にCポインタを渡します：

```julia
width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)
```

Upon return, the contents of `width` and `range` can be retrieved (if they were changed by `foo`) by `width[]` and `range[]`; that is, they act like zero-dimensional arrays.
> 返ってくると、 `width`と` range`の内容は `width []`と `range []`で取り出すことができます( `foo`によって変更された場合)。 つまり、それらはゼロ次元配列のように動作します。

### Special Reference Syntax for ccall (deprecated):
> ### ccallの特別な参照構文(非推奨)：

The `&` syntax is deprecated, use the `Ref{T}` argument type instead.
> `＆`構文は廃止されました。代わりに `Ref {T}`引数型を使用してください。

A prefix `&` is used on an argument to [`ccall`](@ref) to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). 
> スカラー値そのものの代わりにスカラー引数へのポインタを渡す必要があることを示すために、 `` ccall` '(@ref)への引数に接頭辞 `＆`が使われます(上記のようにすべてのFortran関数の引数に必要です) 。
The following example computes a dot product using a BLAS function.
> 次の例では、BLAS関数を使用してドット積を計算します。

```julia
function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),
                    &n, DX, &incx, DY, &incy)
    return product
end
```

The meaning of prefix `&` is not quite the same as in C. 
> 接頭辞 `＆`の意味はCとまったく同じではありません。
In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via `type`). 
> 特に、参照型変数の変更は、型が変更可能( `type`を介して宣言されている)でない限り、Juliaでは表示されません。
However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). 
> しかし、変更不能な構造体であっても、呼び出された関数がそのような変更を試みること(つまり、渡されたポインタを介して書き込む)には何の害も生じません。
Moreover, `&` may be used with any expression, such as `&0` or `&f(x)`.
> さらに、 `＆`は `＆0`や`＆f(x) `のような式と一緒に使うことができます。

When a scalar value is passed with `&` as an argument of type `Ptr{T}`, the value will first be converted to type `T`.
> `Ptr {T}`型の引数としてスカラー値が `＆`で渡されると、その値はまず `T`型に変換されます。

## Some Examples of C Wrappers
> ## Cラッパーのいくつかの例

Here is a simple example of a C wrapper that returns a `Ptr` type:
> `Ptr`型を返すCラッパーの簡単な例を以下に示します：


```julia
mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end
```

The [GNU Scientific Library](https://www.gnu.org/software/gsl/) (here assumed to be accessible through `:libgsl`) defines an opaque pointer, `gsl_permutation *`, as the return type of the C function `gsl_permutation_alloc()`. 
> [GNU科学的ライブラリ(https://www.gnu.org/software/gsl/)は(ここで `を介してアクセス可能であると仮定する：libgsl`)の戻り型として、不透明ポインタ、` gsl_permutation *を `定義しますC関数 `gsl_permutation_alloc()`を呼び出します。
As user code never has to look inside the `gsl_permutation` struct, the corresponding Julia wrapper simply needs a new type declaration, `gsl_permutation`, that has no internal fields and whose sole purpose is to be placed in the type parameter of a `Ptr` type.  
> ユーザーコードは `gsl_permutation`構造体の内部を見るために持っていたことがないよう、対応するジュリアラッパーは、単に唯一の目的である`のPtrの型パラメータに配置すべき内部フィールドとを持っていない新しいタイプの宣言、 `gsl_permutation`を、必要とします`タイプ。
The return type of the [`ccall`](@ref) is declared as `Ptr{gsl_permutation}`, since the memory allocated and pointed to by `output_ptr` is controlled by C (and not Julia).
> [ `ccall`](@ REF)の戻り型は、メモリが割り当てられているので、`のPtr {gsl_permutation} `として宣言とoutput_ptr`はC(としないジュリア)によって制御されている`によって指し示されています。

The input `n` is passed by value, and so the function's input signature is simply declared as `(Csize_t,)` without any `Ref` or `Ptr` necessary. 
> 入力 `n`は値によって渡されるので、関数の入力シグネチャは` Ref`または `Ptr`を必要とせずに`(Csize_t、) `として単に宣言されます。
(If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be `(Ref{Csize_t},)`, since Fortran variables are passed by reference.) 
> (ラッパーが代わりにFortran関数を呼び出していた場合、対応する関数入力シグネチャはFortran変数が参照渡しされるため、 `(Ref {Csize_t}、)`にする必要があります。
Furthermore, `n` can be any type that is convertable to a `Csize_t` integer; the [`ccall`](@ref) implicitly calls [`Base.cconvert(Csize_t, n)`](@ref).
> さらに、 `n`は` Csize_t`整数に変換可能な任意の型であることができます。 [`ccall`](@ref)は暗黙的に[` Base.cconvert(Csize_t、n) `](@ref)を呼び出します。

Here is a second example wrapping the corresponding destructor:
> 対応するデストラクタをラップする2番目の例を次に示します。

```julia
# The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Void,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end
```

Here, the input `p` is declared to be of type `Ref{gsl_permutation}`, meaning that the memory that `p` points to may be managed by Julia or by C. 
> ここで、入力 `p`は` Ref {gsl_permutation} `型で宣言されています。つまり、` p`が指すメモリはJuliaやCによって管理されている可能性があります。
A pointer to memory allocated by C should be of type `Ptr{gsl_permutation}`, but it is convertable using [`Base.cconvert()`](@ref) and therefore can be used in the same (covariant) context of the input argument to a [`ccall`](@ref). 
> Cによって割り当てられたメモリへのポインタは、 `Ptr {gsl_permutation}`型でなければなりませんが、[`Base.cconvert()`](@ref)を使って変換可能であるため、同じ(共変) [`ccall`](@ref)に引数を入力してください。
A pointer to memory allocated by Julia must be of type `Ref{gsl_permutation}`, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. 
> Juliaによって割り当てられたメモリへのポインタは、指し示されるメモリアドレスが有効でJuliaのガベージコレクタが正しく指し示されたメモリのチャンクを管理するように、 `Ref {gsl_permutation}`型でなければなりません。
Therefore, the `Ref{gsl_permutation}` declaration allows pointers managed by C or Julia to be used.
> したがって、 `Ref {gsl_permutation}`宣言により、CまたはJuliaが管理するポインタを使用することができます。

If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using `p::Ptr{gsl_permutation}` for the method signature of the wrapper and similarly in the [`ccall`](@ref) is also acceptable.
> CラッパーがJuliaが管理するメモリにポインタを渡すことをユーザーが期待していない場合は、ラッパーのメソッドシグネチャに `p :: Ptr {gsl_permutation}`を使用し、[`ccall`](@ref)にも同様に 許容される。

Here is a third example passing Julia arrays:
> Julia配列を渡す3番目の例を次に示します。

```julia
# The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax < nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end
```

The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array `result_array`. 
> ラップされたC関数は整数エラーコードを返します。 Bessel J関数の実際の評価の結果は、Julia配列 `result_array`に代入されます。

This variable can only be used with corresponding input type declaration `Ref{Cdouble}`, since its memory is allocated and managed by Julia, not C. 
> この変数は対応する入力型宣言 `Ref {Cdouble}`でのみ使用できます。そのメモリはC言語ではなくJuliaによって割り当てられ、管理されているからです。
The implicit call to [`Base.cconvert(Ref{Cdouble}, result_array)`](@ref) unpacks the Julia pointer to a Julia array data structure into a form understandable by C.
> [`Base.cconvert(Ref {Cdouble}、result_array)`](@ref)への暗黙の呼び出しは、Julia配列のデータ構造体へのJuliaポインタをCが理解できる形式に展開します。

Note that for this code to work correctly, `result_array` must be declared to be of type `Ref{Cdouble}` and not `Ptr{Cdouble}`. 
> このコードが正しく動作するためには、 `result_array`は` Pt {{Cdouble} 'ではなく `Ref {Cdouble}'型であると宣言されなければなりません。
The memory is managed by Julia and the `Ref` signature alerts Julia's garbage collector to keep managing the memory for `result_array` while the [`ccall`](@ref) executes.
> メモリはJuliaによって管理され、 `` ccall`(@ref)が実行されている間、 `ref`シグネチャはJuliaのガベージコレクタに` result_array`のためのメモリ管理を継続するよう警告します。
If `Ptr{Cdouble}` were used instead, the [`ccall`](@ref) may still work, but Julia's garbage collector would not be aware that the memory declared for `result_array` is being used by the external C function. 
> もし `Ptr {Cdouble}`が代わりに使われていれば、 `` ccall``(@ref)は動作するかもしれませんが、Juliaのガベージコレクタは `result_array`のために宣言されたメモリが外部のC関数によって使われていることを認識しません。
As a result, the code may produce a memory leak if `result_array` never gets freed by the garbage collector, or if the garbage collector prematurely frees `result_array`, the C function may end up throwing an invalid memory access exception.
> 結果として、 `result_array`がガベージコレクタによって決して解放されない場合、またはガベージコレクタが早期に` result_array`を解放する場合、コードはメモリリークを生成する可能性があり、C関数は無効なメモリアクセス例外をスローします。

## Garbage Collection Safety
> ## ガーベージコレクションの安全性

When passing data to a [`ccall`](@ref), it is best to avoid using the [`pointer()`](@ref) function.
> データを[`ccall`](@ref)に渡すときは、[` pointer() `](@ref)関数を使わないことをお勧めします。
Instead define a convert method and pass the variables directly to the [`ccall`](@ref). 
> 代わりにconvertメソッドを定義し、変数を直接[`ccall`](@ref)に渡します。
[`ccall`](@ref) automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. 
> [`ccall`](@ref)は、呼び出しが返るまで、すべての引数がガベージコレクションから保存されるよう自動的に調整します。
If a C API will store a reference to memory allocated by Julia, after the [`ccall`](@ref) returns, you must arrange that the object remains visible to the garbage collector. 
> C APIがJuliaによって割り当てられたメモリへの参照を格納する場合、[`ccall`](@ref)が返った後、オブジェクトがガベージコレクタに見えるようにする必要があります。
The suggested way to handle this is to make a global variable of type `Array{Ref,1}` to hold these values, until the C library notifies you that it is finished with them.
> これを処理するための推奨される方法は、Cライブラリが終了したことを通知するまで、 `Array {Ref、1}`型のグローバル変数にこれらの値を保持させることです。

Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. 
> Juliaデータへのポインタを作成したら、ポインタを使用して完了するまで、元のデータが存在することを確認する必要があります。
Many methods in Julia such as [`unsafe_load()`](@ref) and [`String()`](@ref) make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. 
> Juliaの[`unsafe_load()`](@ref)や[`String()`](@ref)のような多くのメソッドは、バッファの所有権を取る代わりにデータのコピーを作成します。 Juliaに影響を与えずに元のデータを変更します。
A notable exception is [`unsafe_wrap()`](@ref) which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.
> パフォーマンス上の理由から、根底にあるバッファを共有している(または所有権を奪取することができる)[`unsafe_wrap()`](@ref)は例外です。

The garbage collector does not guarantee any order of finalization. 
> ガベージコレクタは、ファイナライズの順序を保証しません。
That is, if `a` contained a reference to `b` and both `a` and `b` are due for garbage collection, there is no guarantee that `b` would be finalized after `a`. 
> すなわち、 `a`が` b`への参照を含み、 `a`と` b`の両方がガベージコレクションの対象である場合、 `b`が` a`の後にファイナライズされるという保証はありません。
If proper finalization of `a` depends on `b` being valid, it must be handled in other ways.
> `a`の適切なファイナライゼーションが` b`が有効であることに依存する場合、それは他の方法で処理されなければなりません。

## Non-constant Function Specifications
> ## 非定数関数の仕様

A `(name, library)` function specification must be a constant expression. However, it is possible to use computed values as function names by staging through `eval` as follows: 
> `(name、library)`関数の指定は定数式でなければなりません。しかし、次のように `eval`をステージングすることによって計算された値を関数名として使用することは可能です：
```
@eval ccall(($(string("a", "b")), "lib"), ...
```

This expression constructs a name using `string`, then substitutes this name into a new [`ccall`](@ref) expression, which is then evaluated. 
> この式は `string`を使って名前を構成し、次にこの名前を新しい[` ccall`](@ref)式に代入して評価します。
Keep in mind that `eval` only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with `$`). For this reason, `eval` is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.
> `eval`はトップレベルでしか動作しないので、この式では、ローカル変数は(それらの値が` $ `で置き換えられない限り)利用できません。このため、通常、evalはトップレベルの定義を形成するためにのみ使用されます。たとえば、多くの同様の関数を含むライブラリをラップする場合です。

If your usage is more dynamic, use indirect calls as described in the next section.
> 使用方法がさらに動的な場合は、次のセクションで説明するように間接呼び出しを使用します。

## Indirect Calls
> ## 間接通話

The first argument to [`ccall`](@ref) can also be an expression evaluated at run time. 
> [`ccall`](@ref)の最初の引数は、実行時に評価される式でもあります。
In this case, the expression must evaluate to a `Ptr`, which will be used as the address of the native function to call. 
> この場合、式は `Ptr`に評価されなければなりません。これは呼び出すネイティブ関数のアドレスとして使われます。
This behavior occurs when the first [`ccall`](@ref) argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.
> この現象は、最初の[`ccall`](@ref)引数に、ローカル変数、関数引数、または非定数グローバルなどの非定数への参照が含まれている場合に発生します。

For example, you might look up the function via `dlsym`, then cache it in a shared reference for that session. 
> たとえば、 `dlsym`を使って関数を検索し、そのセッションの共有参照にキャッシュすることができます。
For example:
> 例えば：

```julia
macro dlsym(func, lib)
    z = Ref{Ptr{Void}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))::Ptr{Void}
                $z[] = $zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Void, ())
```

## Calling Convention
> ## 呼出規約

The second argument to [`ccall`](@ref) can optionally be a calling convention specifier (immediately preceding return type). 
> [`ccall`](@ref)の第2引数は、オプションで呼び出し規約指定子(直前の戻り値の型)です。
Without any specifier, the platform-default C calling convention is used. 
> どのような指定子もなければ、プラットフォームのデフォルトのC呼び出し規約が使用されます。
Other supported conventions are: `stdcall`, `cdecl`, `fastcall`, and `thiscall` (no-op on 64-bit Windows). 
> 他のサポートされている規則は、 `stdcall`、` cdecl`、 `fastcall`、` thiscall`(64ビットWindowsではno-op)です。
For example (from `base/libc.jl`) we see the same `gethostname`[`ccall`](@ref) as above, but with the correct signature for Windows:
> たとえば( `base / libc.jl`から)、上記の` gethostname` [`ccall`](@ref)と同じですが、Windowsの正しい署名が付いています：

```julia
hn = Vector{UInt8}(256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))
```

For more information, please see the [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions).
> 詳細については、 [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions) を参照してください。

There is one additional special calling convention `llvmcall`, which allows inserting calls to LLVM intrinsics directly.
> 特別な呼び出し規約 `llvmcall`がもう1つあります。これにより、LLVM組み込み関数への呼び出しを直接挿入することができます。
This can be especially useful when targeting unusual platforms such as GPGPUs.
> これは、GPGPUなどの珍しいプラットフォームをターゲットにする場合に特に便利です。
For example, for [CUDA](http://llvm.org/docs/NVPTXUsage.html), we need to be able to read the thread index:
> たとえば、[CUDA](http://llvm.org/docs/NVPTXUsage.html)では、スレッドインデックスを読み取ることができる必要があります。

```julia
ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())
```

As with any `ccall`, it is essential to get the argument signature exactly correct.
> `ccall`と同様に、引数の署名を正確に得ることが不可欠です。
Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by `Core.Intrinsics`.
> また、組み込み関数が意味を持ち、現在のターゲット上で動作することを保証する互換性レイヤーがないことに注意してください。 `Core.Intrinsics`によって公開される同等のJulia関数とは異なります。

## Accessing Global Variables
> ## グローバル変数へのアクセス

Global variables exported by native libraries can be accessed by name using the [`cglobal()`](@ref) function. 
> ネイティブライブラリによってエクスポートされたグローバル変数は、[`cglobal()`](@ref)関数を使って名前でアクセスできます。
The arguments to [`cglobal()`](@ref) are a symbol specification identical to that used by [`ccall`](@ref), and a type describing the value stored in the variable:
> [`cglobal()`](@ref)への引数は、[`ccall`](@ref)で使われるものと同じシンボル指定であり、変数に格納されている値を記述する型です：

```julia-repl
julia> cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8
```

The result is a pointer giving the address of the value. The value can be manipulated through this pointer using [`unsafe_load()`](@ref) and [`unsafe_store!()`](@ref).
> 結果は値のアドレスを与えるポインタです。この値は、[`unsafe_load()`](@ref)と[`unsafe_store！()`](@ref)を使って操作することができます。

## Accessing Data through a Pointer
> ## ポインタによるデータへのアクセス

The following methods are described as "unsafe" because a bad pointer or type declaration can cause Julia to terminate abruptly.
> 次のメソッドは、不正なポインタまたは型宣言によってJuliaが突然終了する可能性があるため、「安全でない」と記述されています。

Given a `Ptr{T}`, the contents of type `T` can generally be copied from the referenced memory into a Julia object using `unsafe_load(ptr, [index])`. 
> `Ptr {T}`が与えられた場合、 `unsafe_load(ptr、[index])`を使って、 `T`型の内容を参照メモリからJuliaオブジェクトにコピーすることができます。
The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. 
> インデックス引数はオプションです(デフォルトは1).1ベースのインデックス作成のJulia-conventionに従います。
This function is intentionally similar to the behavior of [`getindex()`](@ref) and [`setindex!()`](@ref) (e.g. `[]` access syntax).
> この関数は意図的に[`getindex()`](@ref)と[`setindex！()`](@ref)(例えば `[]`アクセス構文)の動作に似ています。

The return value will be a new object initialized to contain a copy of the contents of the referenced memory. 
> 戻り値は、参照されるメモリの内容のコピーを含むように初期化された新しいオブジェクトになります。
The referenced memory can safely be freed or released.
> 参照されるメモリは、安全に解放または解放できます。

If `T` is `Any`, then the memory is assumed to contain a reference to a Julia object (a `jl_value_t*`), the result will be a reference to this object, and the object will not be copied. 
> `T`が` Any`の場合、メモリはJuliaオブジェクトへの参照( `jl_value_t *`)を含んでいるとみなされ、結果はこのオブジェクトへの参照になり、オブジェクトはコピーされません。
You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. 
> このケースでは、オブジェクトが常にガベージコレクタに表示されていた(ポインタはカウントされませんが、新しい参照は)ことを確認して、メモリが早期に解放されないように注意する必要があります。
Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector.  
> オブジェクトがもともとJuliaによって割り当てられていない場合、新しいオブジェクトはJuliaのガベージコレクタによって決着されることはないことに注意してください。
If the `Ptr` itself is actually a `jl_value_t*`, it can be converted back to a Julia object reference by [`unsafe_pointer_to_objref(ptr)`](@ref).
> `Ptr`自体が実際に` jl_value_t * `であれば、[` unsafe_pointer_to_objref(ptr) `](@ref)でJuliaオブジェクトの参照に変換することができます。
(Julia values `v` can be converted to `jl_value_t*` pointers, as `Ptr{Void}`, by calling [`pointer_from_objref(v)`](@ref).)
> (Juliaの値 `v`は` pointer_from_objref(v) `](@ref)を呼び出すことによって` Ptr {Void} `として` jl_value_t * `ポインタに変換できます。

The reverse operation (writing data to a `Ptr{T}`), can be performed using [`unsafe_store!(ptr, value, [index])`](@ref). 
> `` unsafe_store！(ptr、value、[index]) `](@ref)を使って逆の操作(` Ptr {T} `へのデータ書き込み)を行うことができます。
Currently, this is only supported for primitive types or other pointer-free (`isbits`) immutable struct types.
> 現在のところ、これはプリミティブ型やその他のポインタフリー( `isbits`)不変のstruct型に対してのみサポートされています。

Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.
> エラーをスローする操作は現在実装されていない可能性があり、解決できるようにバグとして通知する必要があります。

If the pointer of interest is a plain-data array (primitive type or immutable struct), the function [`unsafe_wrap(Array, ptr,dims,[own])`](@ref) may be more useful. 
> 対象のポインタがプレーンデータ配列(プリミティブ型または不変構造体)である場合、関数 [`unsafe_wrap ([own])]](@ref)がより有用かもしれません。
The final parameter should be true if Julia should "take ownership" of the underlying buffer and call `free(ptr)` when the returned `Array` object is finalized.  
> 最終的なパラメータは、ジュリアが基礎となるバッファの「所有権」を獲得し、返された `Array`オブジェクトがファイナライズされたときに` free(ptr) `を呼び出す必要がある場合は真です。
If the `own` parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.
> own`パラメータが省略された場合やfalseの場合、呼び出し側はすべてのアクセスが完了するまでバッファが存在し続けるようにする必要があります。

Arithmetic on the `Ptr` type in Julia (e.g. using `+`) does not behave the same as C's pointer arithmetic. 
> Juliaの `Ptr`型での算術演算(` + `を使うなど)は、Cのポインタ演算と同じ動作をしません。
Adding an integer to a `Ptr` in Julia always moves the pointer by some number of *bytes*, not elements. 
> Juliaの `Ptr`に整数を加えると、ポインタは常に要素ではなくいくつかのバイト数だけ移動します。
This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.
> このようにして、ポインタ算術から得られるアドレス値は、ポインタの要素タイプに依存しません。

## Thread-safety
> ## スレッドセーフティ

Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to take some extra precautions. 
> 一部のCライブラリは別のスレッドからコールバックを実行しますが、Juliaはスレッドセーフではないので、いくつかの注意を払う必要があります。
In particular, you'll need to set up a two-layered system: the C callback should only *schedule* (via Julia's event loop) the execution of your "real" callback. 
> 特に、2層システムをセットアップする必要があります。 Cのコールバックは、あなたの "本当の"コールバックの実行を* Juliaのイベントループ経由でのみ*スケジュールする必要があります。
To do this, create a `AsyncCondition` object and wait on it:
> これを行うには、 `AsyncCondition` オブジェクトを作成してそれを待ちます：

```julia
cond = Base.AsyncCondition()
wait(cond)
```

The callback you pass to C should only execute a [`ccall`](@ref) to `:uv_async_send`, passing `cond.handle` as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.
> C に渡すコールバックは、引数として `cond.handle` を渡して、`uv_async_send` に [`ccall`](@ref) を実行するだけで、Juliaランタイムとの割り当てや他のやりとりを避けるよう注意してください。

Note that events may be coalesced, so multiple calls to `uv_async_send` may result in a single wakeup notification to the condition.
> イベントが合体する可能性があるので、 `uv_async_send` を複数回呼び出すと、その状態に1回のウェークアップ通知が発生する可能性があります。

## More About Callbacks
> ## コールバックの詳細

For more details on how to pass callbacks to C libraries, see this [blog post](https://julialang.org/blog/2013/05/callback).
> コールバックをCライブラリに渡す方法の詳細については、この[blog post](https://julialang.org/blog/2013/05/callback)を参照してください。

## C++
> ## C++

For direct C++ interfacing, see the [Cxx](https://github.com/Keno/Cxx.jl) package. 
> ダイレクトC ++インタフェースについては、[Cxx](https://github.com/Keno/Cxx.jl) パッケージを参照してください。
For tools to create C++ bindings, see the [CxxWrap](https://github.com/JuliaInterop/CxxWrap.jl) package.
> C++ バインディングを作成するツールについては、[CxxWrap](https://github.com/JuliaInterop/CxxWrap.jl) パッケージを参照してください。
